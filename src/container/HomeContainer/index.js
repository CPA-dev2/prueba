// @flow
import * as React from "react";
import { connect } from "react-redux";
import Home from "../../stories/screens/Home";
import datas from "./data";
import { fetchList } from "./actions";
import PushNotification from 'react-native-push-notification';
// import firebase from 'react-native-firebase';
import {useNotifications } from '@react-native-firebase/app'
import { newToken} from "./actions";
import {setLatitud, setLongitud, setPeticionesGPS} from "../../reducers/modules/comun";
import {Alert, PermissionsAndroid,Platform } from "react-native";
import Geolocation from "react-native-geolocation-service";
import messaging from '@react-native-firebase/messaging';


PushNotification.configure({
  senderID: "YOUR GCM SENDER ID",

  // IOS ONLY (optional): default: all - Permissions to register.
  permissions: {
    alert: true,
    badge: true,
    sound: true
  },
  popInitialNotification: true,

  requestPermissions: true,
});

export interface Props {
  navigation: any,
  conteo: any,
  fetchList: Function,
  newToken: Function,
  data: Object,
  login: any,
}
export interface State {}
class HomeContainer extends React.Component<Props, State> {
  constructor(props){
    super(props);
    this.verificarPermiso = this.verificarPermiso.bind(this);
    this.obtenerPermiso = this.obtenerPermiso.bind(this);
    this.obtenerToken = this.obtenerToken.bind(this);
  }

  async requestWriteExternalStoragePermission() {
    try {
      if(Platform.Version < 33){
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,
          {
            title: "Necesitamos habilite permisos de almacenamiento",
            message:
              "Necesitamos acceder al sistema de archivos para realizar la exportación de PDF's.",
            buttonNeutral: "Preguntar después",
            buttonNegative: "Cancelar",
            buttonPositive: "Habilitar"
          }
        );
        if (granted === PermissionsAndroid.RESULTS.GRANTED) {
          // eslint-disable-next-line no-console
          console.log("You can use the file system");
          
        } else {
          Alert.alert("ACTIVAR PERMISOS", "Es posible que algunas funciones no esten disponibles si no autoriza el permiso para utilizar el almacenamiento.");
        }
      }
      
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn(err);
    }
  }

  async requestLocationPermission() {
    try {
      const granted = await PermissionsAndroid.request(
        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
        {
          'title': 'Por favor habilite el GPS',
          'message': 'La aplicación necesita que habilite el GPS'
        }
      );
      if (granted === PermissionsAndroid.RESULTS.GRANTED) {
        Geolocation.getCurrentPosition(
          (position) => {
            if (position){
              const lat = position.coords.latitude;
              const long = position.coords.longitude;
              this.props.setLatitud(lat);
              this.props.setLongitud(long);
            }
          },
          (error) => {
            // error 2 (No location provider available) = No se tiene encendido el GPS
            Alert.alert(
              "Error",
              "ERROR" + error,
              [
                {text: 'Aceptar'}
              ],
              {cancelable: false}
            );
          },
          { enableHighAccuracy: true, timeout: 60000, maximumAge: 60000 }
        );
      } else {
        try {
          Geolocation.getCurrentPosition(
            (position) => {
              if (position) {
                const lat = position.coords.latitude;
                const long = position.coords.longitude;
                this.props.setLatitud(lat);
                this.props.setLongitud(long);
              }
            },
            (error) => {
              // error 2 (No location provider available) = No se tiene encendido el GPS
            },
            {enableHighAccuracy: true, timeout: 60000, maximumAge: 60000}
          );
        }
        catch (e) {
        }
      }
    } catch (err) {
    }
  }


  

  componentDidMount() {
    //this.props.fetchList(datas);
    this.verificarPermiso();
    this.props.setPeticionesGPS(true);
    this.requestLocationPermission();
    this.requestWriteExternalStoragePermission();
    if (!this.props.pidiendoGPS){
      setInterval(() => {
        this.requestLocationPermission();
      }, 60000);
    }
    // this.notificationListener = useNotifications().onNotification((notification: Notification) => {
    //   PushNotification.localNotification({
    //     id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
    //     autoCancel: false, // (optional) default: true
    //     largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
    //     smallIcon: "ic_launcher", // (optional) default: "ic_notification" with fallback for "ic_launcher"
    //     color: "red", // (optional) default: system default
    //     vibrate: true, // (optional) default: true
    //     vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
    //     title: notification.title, // (optional)
    //     message: notification.body, // (required)
    //     playSound: true, // (optional) default: true
    //     ongoing: false,
    //     soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
    //     // actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
    //   });
    // });
  }
  verificarPermiso()
  {
    messaging().hasPermission()
      .then(enabled => {
        if (enabled) {
          this.obtenerToken();
        } else {
          this.obtenerPermiso();
        }
      });
  }
  obtenerPermiso(){
    messaging().requestPermission()
      .then(() => {
        this.obtenerToken();
      })
      .catch(error => {

      });
  }
  obtenerToken(){
    messaging().getToken()
      .then(fcmToken => {
        if (fcmToken) {
          if (this.props.newToken){
            this.props.newToken(fcmToken);
          }
        } else {
          this.obtenerPermiso();
        }
      });
  }
  componentWillUnmount(){
    // this.notificationListener();
  }
  render() {
    return <Home navigation={this.props.navigation} list={this.props.data} conteo={this.props.conteo} login={this.props.login} />;
  }
}

function bindAction(dispatch) {
  return {
    fetchList: url => dispatch(fetchList(url)),
    newToken: token => dispatch(newToken(token)),
    setLatitud: param => dispatch(setLatitud(param)),
    setLongitud: param => dispatch(setLongitud(param)),
    setPeticionesGPS: param => dispatch(setPeticionesGPS(param)),
  };
}

const mapStateToProps = state => ({
  data: state.homeReducer.list,
  isLoading: state.homeReducer.isLoading,
  conteo: state.imagenes.conteo,
  pidiendoGPS: state.comun.pidiendoGPS,
  login: state.login,
});
export default connect(mapStateToProps, bindAction)(HomeContainer);
